/**
 * driver - Sample application for calculating steering and acceleration commands.
 * Copyright (C) 2012 - 2015 Christian Berger
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <stdio.h>
#include <math.h>
#include <stdint.h>

#include "core/io/ContainerConference.h"
#include "core/data/Container.h"
#include "core/data/Constants.h"
#include "core/data/control/VehicleControl.h"
#include "core/data/environment/VehicleData.h"

#include "GeneratedHeaders_Data.h"

#include "Driver.h"

namespace msv {

        using namespace std;
        using namespace core::base;
        using namespace core::data;
        using namespace core::data::control;
        using namespace core::data::environment;

        Driver::Driver(const int32_t &argc, char **argv) :
	        ConferenceClientModule(argc, argv, "Driver") {
        }

        Driver::~Driver() {}

        void Driver::setUp() {
	        // This method will be call automatically _before_ running body().
        }

        void Driver::tearDown() {
	        // This method will be call automatically _after_ return from body().
        }
        /*void BothInfraredDetect(){
        Container containerVehicleData = getKeyValueDataStore().get(Container::VEHICLEDATA);
        VehicleData vd = containerVehicleData.getData<VehicleData> ();
        double infraredRearRight = sbd.getValueForKey_MapOfDistances(2);
        double infraredFrontRight= sbd.getValueForKey_MapOfDistances(0);
        if((infraredRearRight>0) &&(infraredFrontRight>0)){
        }
        }*/
       /* void RearInfraredDetect(){
        getModuleState();
        Container containerSensorBoardData = getKeyValueDataStore().get(Container::USER_DATA_0);
        SensorBoardData sbd = containerSensorBoardData.getData<SensorBoardData> ();
        double infraredRearRight = sbd.getValueForKey_MapOfDistances(2);
        double infraredFrontRight= sbd.getValueForKey_MapOfDistances(0);
        if((infraredRearRight>0) && (infraredFrontRight<0)){
        double desiredSteeringWheelAngle;
        desiredSteeringWheelAngle=-25;
        
        }
        }
        void FrontInfraredDetect(){
        Container containerSensorBoardData = getKeyValueDataStore().get(Container::USER_DATA_0);
        SensorBoardData sbd = containerSensorBoardData.getData<SensorBoardData> ();
        double infraredFrontRight= sbd.getValueForKey_MapOfDistances(0);
        double desiredSteeringWheelAngle;
        if (infraredFrontRight=1){
        desiredSteeringWheelAngle=25;
        }
        }
        void turnleft(){
        double desiredSteeringWheelAngle;
        desiredSterringWheelAngle=-25
        } 
        void Overtakingmode(){
               turnleft();
               FrontInfraredDetect();
               RearInfraredDetect();
        
        }*/

        // This method will do the main data processing job.
        ModuleState::MODULE_EXITCODE Driver::body() {
                int Overtakingmode=0;
               int Overtakingcomplete=0;

	        while (getModuleState() == ModuleState::RUNNING) {
                // In the following, you find example for the various data sources that are available:

                // 1. Get most recent vehicle data:
                Container containerVehicleData = getKeyValueDataStore().get(Container::VEHICLEDATA);
                VehicleData vd = containerVehicleData.getData<VehicleData> ();
                                cerr << "Most recent vehicle data: '" << vd.toString() << "'" << endl;

                // 2. Get most recent sensor board data:
               Container containerSensorBoardData = getKeyValueDataStore().get(Container::USER_DATA_0);
                SensorBoardData sbd = containerSensorBoardData.getData<SensorBoardData> ();

                                cerr << "Most recent sensor board data: '" << sbd.toString() << "'" << endl;

                // 3. Get most recent user button data:
                Container containerUserButtonData = getKeyValueDataStore().get(Container::USER_BUTTON);
                UserButtonData ubd = containerUserButtonData.getData<UserButtonData> ();
                                cerr << "Most recent user button data: '" << ubd.toString() << "'" << endl;

                // 4. Get most recent steering data as fill from lanedetector for example:
                  Container containerSteeringData = getKeyValueDataStore().get(Container::USER_DATA_1);
                  SteeringData sd = containerSteeringData.getData<SteeringData> ();
                                cerr << "Most recent steering data: '" << sd.toString() << "'" << endl;

                
                // Design your control algorithm here depending on the input data from above.
                   
                    double infraredRearRight = sbd.getValueForKey_MapOfDistances(2);
                    double ultraSonicFrontCenter = sbd.getValueForKey_MapOfDistances(3);
                    double infraredFrontRight= sbd.getValueForKey_MapOfDistances(0);
                   // double ultraSonicRearRight = sbd.getValueForKey_MapOfDistances(5);
                    // double infraredRear= sbd.getValueForKey_MapOfDistances(1);
                  //  double ultraSonicFrontRight = sbd.getValueForKey_MapOfDistances(4);
                    double desiredSteeringWheelAngle = 0;
                    
                    
                    //int Lanedetectionmode=1;
            //   double steeringAngle=sd.getExampleData();



                // Create vehicle control data.
                VehicleControl vc;
//                    cerr << "relative path: '" << vd.getRelTraveledPath() << "'" << endl;
//                    cerr << "absolute path: '" << vd.getAbsTraveledPath() << "'" << endl;


                // With setSpeed you can set a desired speed for the vehicle in the range of -2.0 (backwards) .. 0 (stop) .. +2.0 (forwards)
                 //   cerr << "rearRight: '" << infraredRearRight << "'" << endl;

                  vc.setSpeed(2);
  //Overtaking at straight line
              //  if ((steeringAngle>=-0.00000001)&& (steeringAngle<=0.00000001)){
             /*   if (ultraSonicFrontCenter < 6) {
                         Overtakingmode=1;
                        
                }
                if (Overtakingmode==1){
                  
                	desiredSteeringWheelAngle=-80;
                	if(infraredFrontRight>0) {
                		desiredSteeringWheelAngle=20;
                	}
                	if((infraredFrontRight>0) && (infraredRearRight>0)){
                		desiredSteeringWheelAngle=10;
                	}
                	if((infraredFrontRight<0) && (infraredRearRight>0)){
                		desiredSteeringWheelAngle=10; 

                        Overtakingcomplete=1;
                 
                	}
              
               
                	if((infraredFrontRight<0) && (infraredRearRight<0)&&(Overtakingcomplete==1)){
                		desiredSteeringWheelAngle=30;

                	}
                 Overtakingmode=0;
                	
                } */
                
            //   }
              //Overtaking at curve.// need to fix steering data at lanedetector and get them at overtaking. Else it doesnt work.
              if((ultraSonicFrontCenter<8)&&(infraredFrontRight<0)&&(infraredRearRight<0)){
                 Overtakingmode=1;
              
                }
             
                if(Overtakingmode==1){
                 desiredSteeringWheelAngle=-26;
                if((infraredFrontRight>0) &&(infraredRearRight<0)){
                desiredSteeringWheelAngle=26;
                
                }
                if((infraredFrontRight>0) &&(infraredRearRight>0)){
                desiredSteeringWheelAngle=26;
            
                }
                if((infraredFrontRight<0) && (infraredRearRight>0)){
                desiredSteeringWheelAngle=26;
                Overtakingcomplete=1;
                }
                if((infraredFrontRight<0) && (infraredRearRight<0)&&(Overtakingcomplete==1)){
                		desiredSteeringWheelAngle=30;
                }
                Overtakingmode=0;
                }

               // else if(steeringAngle


                // With setSteeringWheelAngle, you can steer in the range of -26 (left) .. 0 (straight) .. +25 (right)
                 // 4 degree but SteeringWheelAngle expects the angle in radians!
                vc.setSteeringWheelAngle(desiredSteeringWheelAngle * Constants::DEG2RAD);

                // You can also turn on or off various lights:
                vc.setBrakeLights(false);
                vc.setLeftFlashingLights(false);
                vc.setRightFlashingLights(true);

                // Create container for finally sending the data.
                Container c(Container::VEHICLECONTROL, vc);
                // Send container.
                getConference().send(c);
	        }

	        return ModuleState::OKAY;
        }
} // msv 
